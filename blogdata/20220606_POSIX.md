兜兜转转，也可以说成是返璞归真，我从使用 Linux 到 WSL 再到完全改回 Windows 作为主力机了。写一篇文章主要陈述 Windows 上的 POSIX 环境，以及其它。

## 写在最前
不知不觉又到了高考的日子，离我的高考已经有5年了。回忆过去还是很感慨的。在这个多灾多难的年代，尽管没人看我的博客，还是祝所有的高考学子能够取得满意的成绩。也希望他们能在越过这个卷到顶峰的坎后收获自己的爱情。

## 为何不使用 Linux？
我承认使用 Linux 对于搞科研和开发的人来说是最方便的，但是 Linux 打不了我想玩的游戏。这一条理由就够了。我不想每次需要工作了或者每次需要娱乐了就重新启动电脑。诚然这样可以让我减少娱乐时间，但是娱乐的时候突然被叫去干活，如果需要重启也很麻烦。

这种情况也许需要多台电脑。我办公室那一台是不是应该换成 Linux 呢？或许是个不错的选择……但是这样的话给 Windows 开发就只有自己的笔记本了。

在 Linux 里面开一个 Windows 虚拟机作为轻量使用似乎也不错，但是给人的感觉很重，不舒服。

## WSL 的问题
其实我并没有完全放弃 WSL，但是唯一的 WSL 几个月不打开一次，实在是用不上。如果我需要 Linux，有服务器可以用。

WSL1 各方面都不错，可惜微软弃坑了。WSL2 的主要问题是 Hyper-V 的兼容性。我日常需要一个安卓模拟器玩游戏，大部分的安卓模拟器是基于 VirtualBox 的，和 Hyper-V 不兼容。另外我还有个黑苹果的 VMware 虚拟机，也不能兼容 Hyper-V。

安卓模拟器倒是可以用 WSA 替代，但是 WSA 的性能不如专业模拟器。

我的日常并不需要针对 Linux 开发，而是一些跨平台开发；如果需要到 Linux 上做什么，到服务器上也不错，并不一定要在本地跑。

但是，如果这些问题都可以接受，WSL 远比实体 Linux 与虚拟机 Linux 强得多。

## 为什么一定要 POSIX
一些常用的工具是 POSIX 的。PowerShell 虽然很强大，但是需要额外的学习。

另外很大的一个原因是，`git` 离不开 POSIX 环境。

## Cygwin
在这里不讨论到底 POSIX 还是 NT 好，二者有着很大的差异，甚至截然相反的逻辑。但是终归有人在 Windows 上实现了一个 POSIX 标准的环境，即 Cygwin。Cygwin 相当于在 Windows 上提供了一套完整的 `glibc` 实现，因而可以将 Linux 的大部分程序重新编译到 Windows 上。

Cygwin 最大的问题在于慢。如果按照 `libc` 的眼光看它，那它最大的问题就是冗余多、性能差。为了模拟 POSIX 的文件系统特性与进程特性，Cygwin 不得不加上许多冗余的信息。

## MSYS2
MSYS2 是 Cygwin 的一个 fork，但是加上了更加方便与 Windows 原生程序交互的特性。它提供了自动的路径转换功能，以及 `pacman` 作为包管理器，还有基于 MinGW-W64 的原生程序包。

MSYS2 不仅提供了一个 POSIX 环境，也提供了原生性能的各种软件包。`pacman` 也对我这种 Arch Linux 用户很友善。

## MinGW(-W64)
MinGW-W64 是 MinGW 的一个积极维护的 fork。后者的初衷是将一些 GNU 软件放到 Windows 上来。主要是编译器 GCC，以及支持的库。但是后来开发者弃坑了，于是出现了 MinGW-W64 这个 fork。他们把代码移植到 64 位 Windows 上，而且效果不错。

MinGW-W64 并没有完全重写 C 标准库，而是提供了最小的兼容接口，大部分函数直接调用 Windows 上的 C 函数，也就是 MSVC 提供的 C 标准库。因此 MinGW-W64 的一些基础库可以和 MSVC 的库相互链接调用，他们也因此能够直接调用 Windows API。

基于 MinGW-W64 的程序和基于 MSVC 的程序性能相当，有时候甚至 GCC 优化更好一些。

## Git
有一天突发奇想看了看 Git 仓库的 Git 历史，发现一开始人们使用 Git 并不规范并不标准，这些规范都是后来慢慢形成的。Linus 一开始只是想要写一个自己的文件管理工具包，后来才逐渐发展成现在的 Git。

由于 Git 的开发是基于 Linux 的，它自然会假设存在一个 POSIX 环境。有一些脚本基于 `sh`，还有一些基于 `perl`。且不提编码问题或者文件系统这种跨平台开发必然会存在的坑，就算是基础的 shell 脚本，也需要一个 POSIX 环境。

Git for Windows 这个项目组从 Git 仓库 fork 出来，加了亿些补丁，来放到 Windows 上友善地使用。实际上他们打包了一个稍作修改的 MSYS2 运行时，这个运行时提供了一个 `bash` 来运行脚本，还有一个 `perl` 以作不时之需。Git 本身是基于 MinGW-W64 编译的，这是为了更好的性能以及更容易调用 Windows API。

## 自己的打包
个人电脑的未来将是一篇惨淡，因为所有的新软件都想要基于 Electron 开发，一台电脑上将会有 114514 个 Chromium。这对于一些人是不能容忍的，包括我。同样地，我也不原意让 Git 和 MSYS2 提供两份运行时，尽管 Git for Windows 的开发者认为这么做是体验最佳的。

于是我在 MSYS2 上[自己打包](https://github.com/Berrysoft/msys-git-for-windows/) Git，并开心地在版本号里面塞了自己的名字。还加了一些补丁，主要是为了编译。

还有一个补丁是为了处理 shebang。在 POSIX 的逻辑下，一个文件是否可执行要看它的文件特性里面有没有 `+x`，如果有，要么是可执行文件，要么是有 shebang 的脚本文件。Git 的各种脚本就是这么启动的。但是 Windows 的逻辑下并不是这样，何况 shebang 的路径是 POSIX 路径，Windows 识别不了。

于是 Git for Windows 的处理办法是，如果在 Windows 上，就自己识别 shebang，看看它需要什么解释器，再从 `PATH` 中找对应的解释器。为了防止 `PATH` 混乱，他们提供了一个 `cmd/git.exe`，这是一个包装，主要功能就是把需要的 `PATH` 放到环境变量最前面。

但是自己打包是不需要这些的，由于我自己的一些特殊操作，Git 必然会找错 `perl`。这是因为我也受不了 TeXLive 提供的冗余的 POSIX 工具了，想要用 MSYS2 编译好的 TeXLive。TeXLive 需要一个 MinGW-W64 的 `perl`，因为需要调用 Windows API。然而在 `PATH` 中，MinGW-W64 的 `bin` 文件夹在 MSYS2 的 `bin` 前面。恰巧为了给 Git 的上游提交我的几个补丁，需要用到 `git-send-email`，是个 `perl` 脚本，于是挂了。

我最后删掉了 Git 识别 shebang 的逻辑，直接调用 MSYS2 的 `env`，这个简单的 POSIX 程序可以准确地找到需要的解释器。然而当我把这个补丁给 Git for Windows 上游时候，他们[拒绝了](https://github.com/git-for-windows/git/pull/3869)。这是因为没有多少人像我一样折腾，而且 `env` 是一个 MSYS2（或者说 Cygwin）程序，会拖慢启动速度。我承认理论上会拖慢速度，但是……实际上我用得好好的。“我用得很好”这种理由当然不能说服一个项目维护着，但是可以说服我自己。

所以到最后我开始自己打包 Git，还有 Git 的一些工具，放到 CI 上编译并做成软件源。体验很好，但是写在这里推销也没人看，聊以自慰。

## 总结
Windows 总得来说还是折腾少，比 Linux 要轻松，即使是加入了 Insider 也是一样。在这之上搞一个还不算折腾的 POSIX 模拟环境，主要给日常（尤其是 Git）使用，还是很舒服的。一点性能损失，但是可以接受。
